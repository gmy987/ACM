/*
已知n个人（以编号0,1，2，3,…,n-1分别表示）围坐在一张圆桌周围；从编号为k的人开始报数，数到m的那个人出列,如此循环，直至只剩一人。
约瑟夫环的递推公式：  f[1]=0;　f[i]=(f[i-1]+m)%i; (i>1) f[i]为胜利者

公式的推导：
给出一个序列，从0～n-1编号。其中，k代表出列的序号的下一个，即k-1出列。
A: 0, 1, …, k-1, k, k+1, …, n-1

那么，出列的序号是(m-1)%n，k=m%n（这个可真的是显而易见）。出列k-1后，序列变为
B: 0, 1, …, k-2, k, k+1, …, n-1

然后，我们继续从n-1后延长这个序列，可以得到
C`: 0, 1, …, k-2, k, k+1, …, n-1, n, n+1, …, n+k-2

我们取从k开始直到n+k-2这段序列。其实这段序列可以看作将序列b的0~k-2段移到了b序列的后面。这样，得到一个新的序列
C: k, k+1, …, n-1, n, n+1, …, n+k-2

好了，整个序列c都减除一个k，得到
D: 0, 1, …, n-2

C序列中的n-1, n, n+1都减除个k是什么？这个不需要关心，反正c序列是连续的，我们知道了头和尾，就能知道d序列是什么样的。
这样你看，从序列a到序列d，就是一个n序列到n-1序列的变化，约瑟夫环可以通过递推来获得最终结果。ok，继续向下。
剩下的就是根据n-1序列递推到n序列。假设在n-1序列中，也就是序列d中，我们知道了最终剩下的一个序号是x，那么如果知道了x转换到序列a中的编号x`，
不就是知道了最终的结果了么？

下面我们就开始推导出序列A中x的序号是什么。
D->C，这个变换很容易，就是x+k；
C->B，其实就是0~k-2这段序列转换为n~n+k-2这段序列，那么再翻转回去，简单的就是%n，即(x+k)%n。%n以后，k~n-1这段序列值不会发生变化，
      而n~n+k-2这段序列则变成了0～k-2；这两段序列合起来，就是序列b。

于是乎，x`=(x+k)%n。并且，k=m%n，所以x`=(x+m%n)%n=(x+m)%n。公式1就出来了：f[i]=(f[i-1]+m)%i。当然，i=1就是特殊情况了，
f[1]=0。这里还有一个小问题要注意。f[i]=(f[i-1]+m)%i 最后MOD的i是个变量，而不是n。

特别注意以上公式是从0～n-1，若从1～n,则公式应为
f[1]=1;　f[i]=(f[i-1]+m)%i  (i>1);   if(f[i]==0) f[i]=i;
或者
ans[i]=(ans[i-1]+m-1)%(n-i+1) 此时ans[i]为被杀掉的人
*/

#include <iostream>
#include <cstring>
#include <cstdio>

using namespace std;
int table[14];

int main()
{
    memset(table,0,sizeof(table));
    int k;
    while(~scanf("%d",&k)&&k)
    {
        if(table[k])
        {
            printf("%d\n",table[k]);
            continue;
        }
        int n = 2*k,m = 1;
        int f[30] = {0};
        f[0] = 0;
        for( int i = 1 ; i <= k ; i++ )
        {
            f[i] = ( f[i-1] + m - 1 ) % ( n - i + 1);
            if( f[i] < k )
            {
                i = 0;
                m++;
            }
        }
        table[k] = m;
        printf("%d\n",table[k]);
    }

}

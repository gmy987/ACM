/*
X=an*(n-1)!+an-1*(n-2)!+...+ai*(i-1)!+...+a2*1!+a1*0!
ai为整数，并且0<=ai<i(1<=i<=n)

应用实例：
{1,2,3,4,...,n}的排列总共有n!种，将它们从小到大排序，怎样知道其中一种排列是有序序列中的第几个？
如 {1,2,3} 按从小到大排列一共6个：123 132 213 231 312 321。想知道321是{1,2,3}中第几个大的数。
这样考虑：第一位是3，小于3的数有1、2 。所以有2*2!个。再看小于第二位，小于2的数只有一个就是1 ，所以有1*1!=1 所以小于32
的{1,2,3}排列数有2*2!+1*1!=5个。所以321是第6个大的数。2*2!+1*1!是康托展开。
再举个例子：1324是{1,2,3,4}排列数中第几个大的数：第一位是1小于1的数没有，是0个，0*3!，第二位是3小于3的数有1和2，但1已经在第一位了，
所以只有一个数2，1*2! 。第三位是2小于2的数是1，但1在第一位，所以有0个数，0*1!，
所以比1324小的排列有0*3!+1*2!+0*1!=2个，1324是第三个大数。
*/


int fac[] = {1,1,2,6,24,120,720,5040,40320}; //i的阶乘为fac[i]

/*  康托展开.
    {1...n}的全排列由小到大有序，s[]为第几个数  */

int KT ( int n , int s[] )
{
    int i , j , t , sum = 0 ;
    for ( i = 0 ; i < n ; i++ )
    {
        t = 0;
        for ( j = i + 1 ; j < n ; j++ )
            if ( s[j] < s[i] )
                t++;
        sum += t*fac[n-i-1];
    }
    return sum + 1 ;
}

/*
int fac[] = { 1, 1, 2 , 6 , 24 , 120 , 720 , 5040 , 40320 };

int KT ( int n , int s[])
{
    int i , j , t , sum = 0;
    for( i = 0 ; i < n ; i++ )
    {
        t = 0;
        for( j = i + 1 ; j < n ; j++ )
            if( s[i] < s[j] )
                t++
        sum+=t*fac[n-1-i];
    }
    return sum+1;
}*/
